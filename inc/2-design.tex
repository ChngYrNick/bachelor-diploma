\section[ПРОЕКТУВАННЯ СТРУКТУРИ ТА КОМПОНЕНТІВ СИСТЕМИ]{Проектування структури та компонентів системи}

\subsection{Проектування багаторівневої архітектури}

Багаторівнева архітектура є одним із найбільш часто використовуваних
архітектурних шаблонів. При його використанні програмне забезпечення
логічно або фізично поділяється на рівні, де кожен рівень знаходиться на
певному рівні абстракції. Кожен рівень інкапсулює свою логіку і
виставляє загальнодоступний інтерфейс рівня вище. Кожен рівень
може використовувати лише той рівень, який знаходиться на один
рівень нижче (іноді він може використовувати будь-який рівень,
що знаходиться нижче), залежність від рівнів вище не допускається.
Зазвичай використовуються рівні презентації (використовуються
для відображення вмісту користувачем), рівень домену
(містить логіку домену) та рівень джерела даних 
(використовується для доступу до даних у сховищі) \cite{multitier-thesis}.

Структурування програмного забезпечення на рівні полегшує розуміння.
Наприклад, можна зрозуміти, як реалізується конкретна ділова операція,
не знаючи, як вона відображається користувачеві та як дані зберігаються.
Також можна замінити весь рівень різним виконанням,
якщо виконання відповідає одному контракту. Наприклад, ми можемо замінити
виконання реляційної бази даних рівня джерела даних реалізацією NoSQL.
Проблема багаторівневої архітектури полягає в тому,
що вона не дотримується принципу інверсії залежностей. Вищі рівні
зазвичай мають вищий рівень абстракції, але вони залежать від рівнів
нижчого рівня, особливо це стосується рівня домену,
який залежить від рівня джерела даних, що є інфраструктурним кодом низького рівня.

Ерік Еванс обрав у своїй книзі багаторівневу архітектуру як головний
архітектурний зразок, на якому він зосередився найбільше.
Він запропонував чотири рівні для DDD (рисунок \ref{layered-arch}):
рівень інтерфейсу користувача, рівень додатку, рівень
домену та рівень інфраструктури.

Рівень інтерфейсу користувача відповідає за показ даних користувачеві
та інтерпретацію його команд. Замість інтерфейсу користувача може бути 
і інша система.

Рівень додатку - це рівень із сервісами додатку,
який координує операції на рівні домену. Він не містить жодної бізнес-логіки,
він працює лише як посередник між рівнем інтерфейсу користувача та рівнем домену.
Він організовує рівень домену на основі випадків використання,
необхідних рівню користувацького інтерфейсу,
і надає їм інтерфейс API.

Доменний рівень - це серце системи, саме там знаходиться бізнес-логіка програми.
Він містить інформацію про бізнес-знання, правила, концепції та робочі потоки,
виражені через сутності, об'єкти значення, сукупності, події домену та сервіси.

Рівень інфраструктури містить технічні реалізації.
Це може бути доступ до сховища даних через репозиторії,
а також зв'язок з іншими системами або інші реалізації на низькому рівні.
\addimghere{layered-arch}{0.4}{Багаторівнева архітектура}{layered-arch}

Рівні можна створювати як на системному рівні, так і
на рівні обмеженому контексту. Коли рівні створюються на рівні
обмеженого контексту, кожен обмежений контекст є окремою
одиницею і не ділить жодного рівня з іншими обмеженими контекстами,
вони мають свої внутрішні рівні. Ця конструкція більше
відокремлює обмежені контексти, контексти стають більш незалежними
і можуть бути змінені або розгорнуті незалежно в
інших контекстах, що робить контексти більш масштабованими
у майбутньому. Деякі обмежені контексти навіть не повинні
мати багаторівневої архітектури.

\addimghere{layers-bound-ctx}{0.8}{Рівні, що використовуються на рівні обмеженому контексту}{layers-bound-ctx}

На основі концепції багаторівневої архітектури Еріка Еванса і за
використанням принципу інверсії залежностей була 
спроектована архітектура додатку (рисунок \hyperref[b1]{Б.1}).
% \addimghere{app-arch}{0.8}{Архітектура додатку}{app-arch}

\subsection{Моделювання бізнес-логіки}

Бізнес-логіка - це система зв'язків та залежностей елементів бізнес-даних
та правил обробки цих даних відповідно до особливостей ведення окремої діяльності (бізнес-правил),
яка встановлюється при розробці програмного забезпечення,
призначеного для автоматизації цієї діяльності. Бізнес логіка описує бізнес-правила реального світу,
які визначають способи створення, представлення та зміни даних.
Бізнес логіка контрастує з іншими частинами програми,
які мають відношення до низького рівня: управління базою даних,
відображення інтерфейсу користувача, інфраструктура і.т.д \cite{business-def}.

Перш ніж розпочати розробку бізнес-домену, ми повинні визначити
історії користувачів нашого додатку.

Історія користувача - це неформальне загальне пояснення функції
програмного забезпечення, написане з точки зору кінцевого користувача.
Його мета полягає в тому, щоб сформулювати, як функція програмного
забезпечення забезпечить цінність для клієнта \cite{user-story-article}.

Історії користувачів полегшують розуміння та спілкування між розробниками і можуть допомогти командам
документувати своє розуміння системи та її контексту.

Історії користувачів додатку:
\begin{itemize}
		\item Як учасник я хочу мати можливість створювати нову публікацію.
		\item Як учасник, я хочу мати можливість залишити новий коментар під публікацією.
		\item Як учасник, я хочу мати можливість відповідати на коментарі інших учасників.
		\item Як учасник, я хочу мати можливість бачити кількість переглядів у публікації.
		\item Як учасник я хочу мати можливість бачити загальну кількість вподобань певної публікації.
		\item Як учасник я хочу мати можливість бачити загальну кількість вподобань певного коментара.
		\item Як учасник я хочу мати можливість розміщувати лайки у публікації.
		\item Як учасник я хочу мати можливість розміщувати дизлайки у публікації.
		\item Як учасник я хочу мати можливість розміщувати лайки у коментарі.
		\item Як учасник я хочу мати можливість розміщувати дизлайки у коментарі.
\end{itemize}

Далі витягнемо іменники та дієслова із розповідей вище.
Шукаємо іменники, які стануть головними об'єктами, а не атрибутами.

Іменники:
\begin{itemize}
		\item учасник;
		\item публікація;
		\item коментар;
		\item лайк;
		\item дизлайк.
\end{itemize}

Дієслова:
\begin{itemize}
		\item створити нову публікацію;
		\item залишити новий коментар;
		\item бачити загальну кількість лайків;
		\item бачити загальну кількість дизлайків;
		\item відповідати на коментар;
		\item розміщувати лайки;
		\item розміщувати дизлайки;
		\item бачити кількість переглядів публікації.
\end{itemize}

Використовуючи вказані вище іменники та дієслова, ми можемо скласти схему (рисунок \hyperref[b2]{Б.2})
% \addimghere{obj-inter-diagram}{0.8}{Діаграма об'єктної взаємодії}{obj-inter-diagram}

Отримавши діаграму взаємодії об'єктів, ми можемо почати думати про діаграму відповідальності об'єкта.
Однією з найпоширеніших помилок є покладання відповідальності на об'єкт актора, тобто учасника.
Потрібно пам'ятати, що об'єкти повинні піклуватися про себе,
а також повинні бути закриті для безпосереднього спілкування.

Тож давайте слідувати вищезазначеному підходу та розподіляти обов'язки.
Діаграма відповідальності об'єкта зображена на рисунку \hyperref[b3]{Б.3}.
% \addimghere{obj-res-diagram}{0.8}{Діаграма відповідальності об'єкта}{obj-res-diagram}

Після створення діаграми взаємодії об’єктів та відповідальності,
потрібно перейти до складання UML діаграми класів.
UML діаграма класів зображена на рисунку \hyperref[b4]{Б.4}.
% \addimghere{uml-2}{0.8}{UML діаграма класів бізнес-логіки}{uml}


\subsection{Висновки}

У розділі 2 була розроблена архітектура додатку та створена модель бізнес­домену,
що дозволить суттєво спростити процеси проектування та розробки програмного забезпечення.
