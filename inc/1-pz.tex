\section{Сучасний стан проблеми та основні задачі роботи}

\subsection{Огляд існуючих практик проектування та розробки програмного забезпечення}

При проектуванні та розробці програмного забезпечення команда
розробників залучається до проекту, основною метою проектування
та розробки є постачання якісного продукту.
Якість означає повне дотримання вимог, відсутність помилок,
високий рівень безпеки та здатність витримувати великі навантаження 
\cite{tdd-bdd-article}.

Додаток або веб-сайт також повинні додавати цінності клієнтам,
працювати за призначенням та забезпечувати інтуїтивно зрозумілий інтерфейс,
щоб ним можна було користуватися навіть не думаючи. Не дивлячись на те,
що все це досить складно, для спрощення та вдосконалення розробки веб-додатків з’явилися
найкращі практики розробки програмного забезпечення \cite{business-rybakov}.

\subsubsection{Керована тестами розробка}

Керована тестами розробка (Test-driven development, TDD) 
- це підхід до розробки програмного забезпечення,
в якому розробляються тестові кейси, які визначають необхідні покращення або нові функції.
Якщо говорити простими словами, спочатку створюються і перевіряються тестові кейси
для кожної функціональності, а якщо пройти тест не вдається,
то для проходження тесту пишеться новий код \cite{tdd-article}.

Основними перевагами керованою тестами розробки є:

\begin{itemize}
    \item поліпшення якості шляхом виправлення помилок якнайшвидше під час розробки;
		\item значне підвищення якості коду;
		\item покращення розуміння коду оскільки рефакторинг
			вимагає регулярного вдосконалення;
		\item покращення швидкості розробки, оскільки розробникам
			не потрібно витрачати час на відлагодження програми.
\end{itemize}

Принцип роботи керованою тестами розробки зображений на рисунку \ref{tdd}.
\addimghere{tdd}{0.45}{Цикл керованою тестами розробки}{tdd}

Відповідно до досліджень недоліками використання підходу є:

\begin{itemize}
		\item неможливість гарантувати відсутність помилок у програмі,
			навіть за наявності широкого спектру тестових кейсів;
		\item велика витрата часу на розробку тестових кейсів
			та підтримку належних наборів тестів \cite{tdd-thesis}.
\end{itemize}


\subsubsection{Керована поведінкою розробка}

Керована поведінкою розробка (Behavior-driven development, BDD) 
- це синтез та вдосконалення практик, що випливають з
керованої тестами розробки (TDD) та керованою тестами розробки прийняття
(Acceptance test–driven development, ATDD) \cite{bdd-article}.
BDD доповнює TDD та ATDD за допомогою наступних технік:

\begin{itemize}
		\item Мислення «ззовні всередину», іншими словами, застосовувати
			лише ті способи поведінки, які найбільше сприяють цим результатам бізнесу,
			щоб мінімізувати витрати.
		\item Описування поведінки в одній нотації,
			яка є безпосередньо доступною для експертів області,
			тестувальників та розробників, з метою покращення комунікації.
		\item Застосування цих методів аж до найнижчих рівнів абстрагування
			програмного забезпечення, приділяючи особливу увагу розподілу поведінки,
			щоб прогресування залишалося дешевим.
\end{itemize}

Команди, які вже використовують TDD або ATDD, 
можуть захотіти розглянути BDD саме з таких причин:

\begin{itemize}
		\item BDD пропонує більш точні вказівки щодо організації бесіди між розробниками,
			тестувальниками та експертами предметної області.
		\item Інструменти, орієнтовані на підхід BDD, як правило,
			дозволяють автоматично створювати технічну документацію
			та документацію для кінцевих користувачів із “специфікацій” BDD.
\end{itemize}

Недоліком даного підходу є необхідність представити команду розробників для роботи з клієнтом.
Короткий час реакції, необхідний для процесу, означає високий рівень доступності.
Однак, якщо клієнт добре розуміє, що задіяно у проекті розробки,
заснованому на принципах Agile, експерт-клієнт буде доступний у разі потреби.
І якщо команди розробників працюють максимально ефективно,
їх вимоги до експерта-клієнта будуть мінімізовані \cite{bdd-article-2}.


\subsubsection{Неперервна інтеграція}

Неперервна інтеграція (Continuous Integration, CI)
- це практика розробки програмного забезпечення,
при якій зміни кодової бази є інтегрованими в сховища потоків після
побудови та перевірки за допомогою автоматизованого робочого процесу \cite{ci-book}.
Принцип роботи неперервної інтеграції зображений на рисунку \ref{ci}.
\addimghere{ci}{0.55}{Цикл роботи неперервної інтеграції}{ci}

Основні переваги використання неперервної інтеграції:

\begin{itemize}
		\item середній час до роздільної здатності 
			(Mean time to resolution, MTTR) швидший і коротший;
		\item ізоляція несправностей менша і швидша;
		\item підвищений рівень випуску допомагає швидше виявляти
			та виправляти несправності;
		\item автоматизація в CI зменшує кількість помилок,
			які можуть виникнути на багатьох етапах.
\end{itemize}

Недоліки використання неперервної інтеграції:

\begin{itemize}
		\item кодова база повинна бути готова і негайно впроваджена у виробництво,
			як тільки поточний результат буде успішним;
		\item підхід вимагає суворої дисципліни з боку учасників.
			Невдачі у дотриманні процесів незмінно породжуватимуть помилки,
			витрачаючи час і гроші;
		\item деякі галузеві середовища не підходять для неперервної інтеграції.
			Медична сфера та авіація вимагають багато випробувань,
			щоб включити код у загальну систему \cite{ci-article}.
\end{itemize}


\subsubsection{Безперервна доставка}

Безперервна доставка (Continuous delivery, CD) - це підхід до програмної інженерії,
при якому команди продовжують виробляти цінне програмне забезпечення
за короткі цикли та забезпечують надійний випуск програмного
забезпечення в будь-який час \cite{cd-chen}.
Модель безперервної доставки зображена на рисунку \ref{cd-model}

\addimghere{cd}{0.9}{Модель безперервної доставки}{cd-model}

Переваги використання безперервної доставки:

\begin{itemize}
    \item Прискорений час виходу на ринок. Час циклу від задуму
      історій користувачів до виробництва зменшується з кількох місяців
      до двох-п'яти днів. Частота вивільнення зростає від 
      одного разу на один до шести місяців, до одного разу на тиждень \cite{cd-chen}.
    \item Створення правильного продукту. Часті випуски дозволяють
      командам розробників додатків швидше отримувати відгуки
      користувачів. Це дозволяє їм працювати лише над корисними функціями.
      Якщо вони виявляють, що якась функція не є корисною,
      вони не витрачають на неї подальших зусиль. Це допомагає їм створити правильний продукт.
    \item Надійні релізи. Зникає високий рівень стресу та невизначеності,
      пов'язаний з випуском продукту. 
\end{itemize}

Недоліки використання безперервної доставки:

\begin{itemize}
    \item Вартість переходу. Реалізація постійної доставки вимагає
      великих зусиль, часу та грошей. Зміна робочого циклу,
      автоматизація процесу тестування та розміщення ваших
      сховищ у Git - це лише деякі процеси, з якими вам доведеться впоратись.
    \item Важкість в обслуговуванні.  Практики безперервної доставки потребують
      постійної підтримки. Це може бути важко для великих фінансових організацій,
      які пропонують різноманітні послуги. Такі компанії матимуть не один,
      а кілька трубопроводів, деякі з яких можуть навіть закінчуватися
      на різних етапах постачання. Це ускладнює порівняння
      пропускної здатності та часу циклу \cite{cd-article}.
\end{itemize}


\subsection{Концепція предметно-орієнтованого проектування}

Предметно-орієнтоване проектування (Domain-driven design, DDD) 
- це підхід до розробки програмного забезпечення, 
який зосереджує розробку на програмуванні моделі предметної області,
що має глибоке розуміння процесів та правил домену.
Назва походить від книги Еріка Еванса 2003 року,A
яка описує підхід через каталог шаблонів \cite{ddd-evans}.
З тих пір спільнота практиків розвивала ідеї,
породжуючи різні інші книги та навчальні курси.
Підхід особливо підходить для складних доменів,
де потрібно організувати багато часто безладної логіки.

Основні сфери, де DDD може знадобитись:
\begin{itemize}
    \item розуміння предметної області;
    \item співпраця експертів предметної області з розробниками;
    \item проектування систем;
    \item рефакторинг.
\end{itemize}

\subsubsection{Домени}
Домен - це, в основному, те, що робить організація.
Це сфера діяльності компанії, і програмне забезпечення призначене для
вирішення проблем у цій галузі \cite{ddd-vernon}. Домен може бути складений на менші частини,
субдомени. 

Управління доменами визначає диференціацію трьох типів субдоменів:
\begin{itemize}
    \item основний домен;
    \item підтримуючий домен;
    \item загальний домен.
\end{itemize}

Основний домен - найважливіша частина; це серце бізнесу.
Це те, що робить гроші, і на що найбільше зосереджений бізнес,
і це має головне значення для успіху організації \cite{ddd-vernon}.
Основний домен є субдоменом в якому потрібно найбільше застосовувати
предметно-орієнтоване проектування.
Важливо, щоб основному домену приділяли найбільшу увагу,
і щоб він був змодельований, спроектований та розроблений якнайкраще.
Цього слід досягти за рахунок більшого залучення експертів з предметної області
та участі найкращих розробників у команді \cite{ddd-millett}.

Підтримуючі домени - це домени, які не є головним напрямком організації,
але вони допомагають підтримувати основні домени.

Загальний домен є найменш важливим доменом для організації.
Це субдомен, який існує у багатьох системах.
Загальний домен не вимагає особливої уваги,
і в ідеальному випадку існуючий продукт може бути використаний для економії часу,
який можна скоріше вкласти в основний домен.

\subsubsection{Розуміння предметної області}
Предметно-орієнтоване проектування ставить домен в центр кожного етапу розробки програмного забезпечення.
Щоб розробити корисну систему, розробники повинні розуміти домен,
процеси, що відбуваються в певних ситуаціях і як це досягається.
Людей, які надають знання про домен, називають експертами предметної області.

Експерти та розробники доменів повинні часто взаємодіяти протягом
всього процесу розробки. Хоча ця взаємодія може зайняти багато
часу як для експертів доменів, так і для розробників, вона
в довгостроковій перспективі окупиться. Ідеальна ситуація,
коли експерт з доменів може бути постійною частиною команди розробників.
Важливою частиною є пряма та постійна взаємодія між експертами домену
та розробниками, обробка знань на основі традиційної моделі розробки
програмного забезпечення водоспаду, в якій аналітик доменів на
етапі вимог інженерії отримуватиме знання від експертів,
а потім передаватиме їх розробникам, швидше за все,
не призведе до найкращого результати. Це пояснюється тим,
що розробники обмежуються знаннями, які отримав аналітик доменів
і які він визнав корисними. Крім того, якщо розробникам потрібна додаткова
інформація або пояснення, вони або не можуть отримати її від експерта,
оскільки це було зроблено на першому етапі розробки,
або вони можуть робити це дуже рідко, щоб не турбувати експертів домену.

Щоб полегшити обмін знаннями, розробники та експерти доменів повинні мати спільну мову,
яку Ерік Еванс визначає як загальна мова \cite{ddd-evans}.
Загальна мова є результатом поєднання знань розробників та експертів предметної області.
Експерти з доменів повинні надавати правильні терміни для різних ситуацій.
Усі терміни повинні мати точне значення, і не повинно бути двозначності. Це одна з причин,
чому надмірно використовувані слова, такі як менеджер, контролер або служба,
як правило, не є добрими іменами. Загальна мова повинна використовуватися
в усіх аспектах розробки програмного забезпечення протягом усього процесу розробки.
Загальна мова повинна використовуватися в коді з тими самими термінами та поняттями,
що використовуються як імена класів, властивостей, назв методів, тощо \cite{ddd-millett}.

\subsubsection{Модель домену}
Отримані знання про домен зображені в моделі домену.
Модель домену являє собою уявлення про домен, розроблену з урахуванням
потреб випадків використання бізнесу \cite{ddd-millett}.
Модель домену описана за допомогою загальної мови
і працює як зв'язок між експертами предметної області та розробниками,
які пов'язані між собою використовуваною мовою.
Модель домену не є діаграмою (хоча її можна зобразити як таку),
це ідея, що діаграма передбачається передати \cite{ddd-evans}.
Не важливо, щоб модель домену була досконалою,
їй не потрібно повністю відображати реальність.
Мета моделі домену - бути наближеною до реальності, але лише з ділової точки зору,
і вона повинна відображати те, що має значення для бізнесу.

Щоб зробити модель домену найбільш корисною,
необхідно синхронізувати її з фактичним кодом.
Модель домену, яка не відображається в коді,
може стати неактуальною або навіть ввести в оману.
Тому було створено модельований підхід до проектування,
який виступає за тісно пов'язану модель домену та код.
Коли в коді відбуваються серйозні структурні зміни,
наприклад, в результаті постійного поєднання знань,
модель домену слід оновити, щоб відобразити зміни\cite{ddd-evans}.

\subsubsection{Обмежений контекст}

Обмежений контекст - це мовна межа навколо доменної моделі \cite{ddd-vernon}.
Усередині обмеженого контексту поняття моделі, як властивості
та операції, мають особливе значення, і загальна мова використовується для опису моделі.
Один термін в одному обмеженому контексті повинен мати одне точне значення.
Однак той самий термін можна використовувати в різному обмеженому контексті, щоб описати щось інше.

Обмежений контекст дуже корисний у великих доменах з багатим словниковим запасом.
У цих сферах може бути дуже важко встановити,
що всі терміни мають глобальне, точне, єдине і чітке значення.

В ідеалі, одна команда розробників повинна відповідати за один обмежений контекст.
Таким чином, цілісність обмеженого контексту буде краще захищена -
оскільки менша кількість людей буде працювати над одним обмеженим контекстом,
їм буде простіше домовитись про один і той же словниковий запас,
використовувати одну і ту ж загальну мову і не витікати терміни в
інші обмежені контексти. Важливо, що команди формуються навколо
створених обмежених контекстів, а не що обмежені контексти
створюються на основі існуючої структури команди. Пізніше це
змусило б створити необмежений контекст, який не відповідає своїй меті,
виступати як лінгвістична межа, вони були б змушені бути більшими або
меншими залежно від розміру команди, що може призвести до неприродно зміщеної контекстної межі

\subsection{Тактичні шаблони}
Тактичні шаблони - це шаблони, які допомагають управляти складністю моделі.
Роль тактичних шаблонів полягає у захопленні та зображенні об'єктів, їхньої поведінки,
значення, функціонування та взаємозв'язків між ними, єдиним способом.
Даний шаблон говорить про те, як об'єкт з певною функцією та характеристиками
може бути реалізований найкращим чином для забезпечення читабельності,
підтримки або розширюваності всієї моделі.

\subsubsection{Сутність}

Сутність - це об'єкт з атрибутами та функціями, унікальна ідентичність якої є важливою.
Це означає, що навіть якщо деякі атрибути об'єкта змінюються,
об'єкт все одно залишає свою однакову ідентичність.

Сутності часто моделюються як змінні класи з унікальним ідентифікатором (який є незмінним).
Коли ми порівнюємо рівність сутностей, порівнюємо рівність їх ідентифікаторів.

\subsubsection{Об'єкт значення}
Об'єкт значення - це об'єкт, який представлений його значенням.
У об'єктів заначення немає особистості, і якщо вони змінюються,
вони більше не відображають того ж самого занчення. Об'єкти значень особливо корисні,
коли клас має більше атрибутів, а деякі з них діють як група,
разом вони представляють одне значення.
У цьому випадку атрибути слід перемістити до власного класу, який би діяв як одна одиниця \cite{ddd-vernon}.

Ще однією важливою особливістю об'єкта значення є змінність.
Не має значення, який екземпляр класу буде використовуватися,
коли всі атрибути однакові. Завдяки незмінності, також має бути
можливим спільний доступ до одного і того ж екземпляру в кількох місцях,
де ми вимагаємо одне і те ж значення. Об'єкти значень зазвичай
моделюються як незмінні класи. Якщо нам потрібно змінити значення,
краще просто створити новий екземпляр. Два об'єкти значення рівні,
коли їхні атрибути рівні. З об'єктами вартості легше мати справу,
оскільки нам не потрібно гарантувати унікальність ідентичності.
Це одна з причин, чому їм слід надавати перевагу над сутностями, якщо це можливо.

\subsubsection{Сервіс}
Сервіси - це об'єкти без стану, які забезпечують функціональність домену.
Вони вводяться, коли існує більш складна ділова функціональність,
яка не є безпосередньою відповідальністю жодного з існуючих об'єктів 
(сутності або об'єкт вартості), і зазвичай вимагає співпраці більшої
кількості об'єктів. Доменними службами слід користуватися з обережністю,
лише коли це необхідно, оскільки надмірне використання доменних сервісів
може призвести до анемічної моделі домену де логіка всього домену
знаходиться в сервісах замість сутностей або об'єктів значення \cite{ddd-vernon}.

\subsubsection{Сукупність}
Сукупність - це група сутностей та об'єктів вартості,
які разом утворюють кордон узгодженості транзакцій.
Сукупність в цілому повинна бути узгодженою в будь-який момент часу.
Отже, створюється корінь сукупності, яка служить точкою входу до сукупності,
інші сутності та об'єкт значення вважаються внутрішніми для
сукупності і не можуть бути доступні безпосередньо ззовні.

Слід бути особливо обережним при проектуванні сукупностей,
оскільки неправильно створені межі сукупностей можуть спричинити проблеми.
Завелика сукупність, як правило, погано працює, оскільки для
забезпечення узгодженості, вносячи зміни до одного об'єкта сукупності,
інші агрегати потрібно блокувати. Якщо об'єкт не мають багато спільного,
це зайве. Як правило, при проектуванні сукупностей необхідно знати
інваріанти моделі та проектувати межі сукупностей на основі них,
а не на основі логічного групування \cite{ddd-vernon}.

\subsubsection{Доменна подія}

Подія домену є новим шаблоном, ніж попередні.
Ерік Еванс не говорить про них у своїй книзі, але це важлива концепція домену.
Вони описують виникнення чогось, що трапилось. Події мають більше ситуацій,
коли вони корисні - їх можна використовувати для запису змін, внесених до сукупності,
або як інструмент комунікації між сукупностями в одному або навіть
різному обмеженому контексті. 

Події домену повинні моделюватися як незмінні об'єкти.
Правильне використання загальної мови та правильне іменування
є особливо важливим. Події слід називати у минулому часі на основі дії, що сталася.

\subsubsection{Фабрика}
Фабрика - це шаблон який відповідає за створення складних об'єктів та сукупностей.
Це корисно в основному, коли сукупність складається з багатьох 
сутностей та об'єктів вартості, а формування нової сукупності
вимагає більшої кількості кроків, під час яких сукупність не узгоджується.
Фабрика інкапсулює логіку створення та виробляє повністю послідовну сукупність.
Фабрика може бути реалізована як статичний метод або як окремий клас \cite{patterns-gamma}.

\subsubsection{Модуль}
Модулі - це контейнери доменних об'єктів, і вони допомагають їх
організувати та додатково розкласти модель домену.
Модулі повинні бути спроектовані, маючи на увазі правило низького
зчеплення - правило високої згуртованості. Об'єкти в модулі 
повинні бути цілісними з іншими, вони повинні створювати одну логічну одиницю.
З іншого боку, між різними модулями має бути низький зв'язок,
об'єкти в одному модулі повинні мати якомога менше залежностей
від об'єктів в інших модулях.

\subsection{Висновки}
В першому розділі розглянуто основні аспекти роботи: проведено огляд
та аналіз існуючих практик розробки програмного забезпечення,
представлено основні поняття по темі, наведено переваги використання
предметно-орієнтованого проектування.
